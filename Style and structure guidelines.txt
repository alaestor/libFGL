Special private file/folder/namespace names:
	experimental
	internal
	working
	details
	test
	obj
	bin

Also any file or folder name prefixed with an underscore.

Each include folder, with the exception of private names, shall have a corresponding `.hpp` file of the same name which includes all header files in that folder.

Example `X.hpp` will include all `X/*.hpp`

The `/include/fgl.hpp` will include all top-level headers and therefor should be a comprehensive include of the entire library.
`/include/FGLM` will contain all opt-in features (such as FGL_SHORT_MACROS) and include `fgl.hpp`

# **TESTS**

Each component of the library, where applicable, shall have a unit test in the root `/test/` directory with a folder name that matches the include structure with separators replaced with underscores.

Example: `/include/fgl/debug/fixme.hpp` corresponds with `/test/fgl_debug_fixme`

Unit tests should have minimal includes and no global "using namespace". Test programs return `EXIT_SUCCESS` to signal that the test(s) have passed. Unit tests should strive to use compile-time `static_assert` and consteval functions where ever possible. Where not possible, use `assert`. Where not possible, a test failure should cause the program to return code `EXIT_FAILURE`. Tests should avoid printing to stdout. Each test within a unit test should be granular and represent a minimal subset of component behavior in order to improve debugability. Don't accumulate failures where possible; prefer to fail hard and fast. Use descriptive variable and function names.

Unit test interdependencies are declared in the unit test's `Tupfile`

Each unit test should use a `{unit_test}` bin to locate the test binary. The `{unit_test}` is executed to produce the `$(TEST_DIR)/<%d>` group. The `$(TEST_DIR)/<%d>` group is then forwarded as a dependency to an empty rule which is used produce the `<unit_test_results>` which is queried by the top level FGLLIB `/Tupfile`

`%d` expands to the name of the folder the `Tupfile` is contained inside of. This means that a test can declare an order-only dependency on another test by refering to its folder name as a group.

Here's an example where the test for `component_B` requires the test for `component_A` to pass before `component_B`'s test is compiled. The unimportant noise is replaced with an underscore; only the input and output collections are shown.

test/component_A/tupfile
```
	: _ |> _ |> _ {test_objs}
	: {test_objs} |> _ |> _ {unit_test}
	: {unit_test} |> _ |> $(TEST_DIR)/<%d>
	: | $(TEST_DIR)/<%d> |> |> <unit_test_results>
```
test/component_B/tupfile
```
	: _ | $(TEST_DIR)/<component_A> |> _ |> _ {test_objs}
	: {test_objs} |> _ |> _ {unit_test}
	: {unit_test} |> _ |> $(TEST_DIR)/<%d>
	: | $(TEST_DIR)/<%d> |> |> <unit_test_results>
```



# **STYLE GUIDELINES**
Just a bunch of examples.

favor at-a-glance readability and sane indentation over strict rule adherence.

I'm a text file not a cop.

```
class whispering_snake_case
{};

init{ value };

multline_init{
	value1
	&& value2
};

const auto thing {
	[]() -> thing
	{
		thing{ default value };
		non-trivial thing mutation;
		return thing;
	}()
};
```

```
function_definition(arg) const noexcept(simple conidition)
{ one line body; }

function_definition(
	multiline,
	arg)
const noexcept(
	complicated
	&& noexcept condition)
{
	multiline body;
}

function_call(
	multiline or really long,
	arg
);
```

```
constructor(arg1, arg2)
: m_arg1(arg1), m_arg2(arg2), //... to column limit (~80)
{} // empty body

constuctor(
	arg1,
	arg2,
	arg3)
:
	m_arg1(arg1),
	m_arg2(arg2),
	m_arg3(arg3) //... over column limit (~80)
{
	// body code
}
```

```
// use T_ prefix
template <typename T>
template <typename ... Ts> // OK, but prefer T_descriptions
template <typename T_thing>
template <typename ... T_things>
```

```
// a worst-case example
template
<
	typename ... T_things
>
[[nodiscard]] constexpr inline
const super duper really really really really long long int&
function_with_lots_of_boilerplate(
	super duper really really really really long long int&
		multiline_args1,
	multiline_args2,
	T_things& ... things)
const noexcept(
		bunch of
		&& shit)
	:
		member(),
		initializers()
{
	body;
}
// still decently readable? but, do better...
```
