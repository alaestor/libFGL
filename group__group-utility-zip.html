<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libFGL: Zip</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="tempus.ico" type="image/x-icon" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<!-- BEGIN CUSTOMIZATIONS -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript"> DoxygenAwesomeFragmentCopyButton.init() </script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript"> DoxygenAwesomeParagraphLink.init() </script>
<!-- END CUSTOMIZATIONS -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="tempus.ico"/></td>
  <td id="projectalign">
   <div id="projectname">libFGL
   </div>
   <div id="projectbrief">Intended for use with Tempus Edax Rerum projects. Replacing spoons with shovels.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group-utility-zip.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">Zip</div></div>
</div><!--header-->
<div class="contents">

<p>Iterates over multiple forward ranges of differing types simultaneously.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2f5842e3d908d1680597134a4f0a9489"><td class="memItemLeft" align="right" valign="top"><a id="ga2f5842e3d908d1680597134a4f0a9489" name="ga2f5842e3d908d1680597134a4f0a9489"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>fgl::zip_sentinel_t</b> = std::ptrdiff_t</td></tr>
<tr class="separator:ga2f5842e3d908d1680597134a4f0a9489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Zip</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp963ab0bbea32f1f9d19afb00d08be14d"></a>The tuple elements from <code>zip</code> are only <code>const</code>-qualified if the input iterator returns <code>const</code> . </p>
</td></tr>
<tr class="memitem:ga71ecba17cfea9c8afe24ac69f1c004fa"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range ... T_ranges&gt; </td></tr>
<tr class="memitem:ga71ecba17cfea9c8afe24ac69f1c004fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utility-zip.html#ga71ecba17cfea9c8afe24ac69f1c004fa">fgl::zip</a> (const std::integral auto length, T_ranges &amp;&amp;... ranges)</td></tr>
<tr class="separator:ga71ecba17cfea9c8afe24ac69f1c004fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd287096faed2bb17d2e9506c7af45bd"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range ... T_ranges&gt; </td></tr>
<tr class="memitem:gadd287096faed2bb17d2e9506c7af45bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utility-zip.html#gadd287096faed2bb17d2e9506c7af45bd">fgl::zip</a> (T_ranges &amp;&amp;... ranges)</td></tr>
<tr class="memdesc:gadd287096faed2bb17d2e9506c7af45bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines length from the size of the smallest range.  <a href="group__group-utility-zip.html#gadd287096faed2bb17d2e9506c7af45bd">More...</a><br /></td></tr>
<tr class="separator:gadd287096faed2bb17d2e9506c7af45bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Const Zip</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp80369da6a7d7898fa697506288f160f8"></a>The tuple elements from <code>czip</code> are always <code>const</code>-qualified. </p>
</td></tr>
<tr class="memitem:ga2782ade415a9fa6ccc855689ad3d91dd"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range ... T_ranges&gt; </td></tr>
<tr class="memitem:ga2782ade415a9fa6ccc855689ad3d91dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utility-zip.html#ga2782ade415a9fa6ccc855689ad3d91dd">fgl::czip</a> (const std::integral auto length, T_ranges &amp;&amp;... args)</td></tr>
<tr class="separator:ga2782ade415a9fa6ccc855689ad3d91dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff12ff083252eda09571cb8fd8653b7e"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range ... T_ranges&gt; </td></tr>
<tr class="memitem:gaff12ff083252eda09571cb8fd8653b7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utility-zip.html#gaff12ff083252eda09571cb8fd8653b7e">fgl::czip</a> (T_ranges &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaff12ff083252eda09571cb8fd8653b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines length from the size of the smallest range.  <a href="group__group-utility-zip.html#gaff12ff083252eda09571cb8fd8653b7e">More...</a><br /></td></tr>
<tr class="separator:gaff12ff083252eda09571cb8fd8653b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Iterates over multiple forward ranges of differing types simultaneously. </p>
<dl class="section attention"><dt>Attention</dt><dd>This fascility may be supplanted entirely by C++23's <code>zip_view</code>, depending its performance. If the standard is sufficient or superior, this facility will be removed.</dd></dl>
<p >A zipped range is a <code>std::ranges::subrange</code> composed of an internal zip iterator and a size-based <code>fgl::zip_sentinel_t</code> end sentinel. The length of the zipped range must always be less than or greater to the size of the smallest range, otherwise the behavior is undefined. The zip iterator is internal because it isn't intended to be used directly by the user; usually only by ranged algorithms and range-based <code>for</code> loops.</p>
<p >Dreferencing the zip iterator returns a <code>std::tuple</code> composed of the results from dereferencing the underlying iterators. These may be values or reference-wrappers depending on what the underlying iterators return.</p>
<p ><code>czip</code> ranges use <code>const</code>-qualified underlying iterators from <code>std::cbegin</code> , while <code>zip</code> ranges use iterators from <code>std::begin</code> . </p>
<dl class="section see"><dt>See also</dt><dd>the example program <a class="el" href="example_2fgl_2utility_2zip_8cpp-example.html">example/fgl/utility/zip.cpp</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga71ecba17cfea9c8afe24ac69f1c004fa" name="ga71ecba17cfea9c8afe24ac69f1c004fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71ecba17cfea9c8afe24ac69f1c004fa">&#9670;&nbsp;</a></span>zip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::forward_range ... T_ranges&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fgl::zip </td>
          <td>(</td>
          <td class="paramtype">const std::integral auto&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_ranges &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if <code>length</code> is greater than the size of the smallest range. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This fascility may be supplanted entirely by C++23's <code>zip_view</code>, depending its performance. If the standard is sufficient or superior, this facility will be removed.</dd></dl>
<p >A zipped range is a <code>std::ranges::subrange</code> composed of an internal zip iterator and a size-based <code>fgl::zip_sentinel_t</code> end sentinel. The length of the zipped range must always be less than or greater to the size of the smallest range, otherwise the behavior is undefined. The zip iterator is internal because it isn't intended to be used directly by the user; usually only by ranged algorithms and range-based <code>for</code> loops.</p>
<p >Dreferencing the zip iterator returns a <code>std::tuple</code> composed of the results from dereferencing the underlying iterators. These may be values or reference-wrappers depending on what the underlying iterators return.</p>
<p ><code>czip</code> ranges use <code>const</code>-qualified underlying iterators from <code>std::cbegin</code> , while <code>zip</code> ranges use iterators from <code>std::begin</code> . </p>
<dl class="section see"><dt>See also</dt><dd>the example program <a class="el" href="example_2fgl_2utility_2zip_8cpp-example.html">example/fgl/utility/zip.cpp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the shortest range. Must be greater than zero and representible by <code>fgl::zip_sentinel_t</code> </td></tr>
    <tr><td class="paramname">ranges</td><td>The ranges to zip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::ranges::subrange</code> which represents the "zipped" ranged. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="example_2fgl_2utility_2zip_8cpp-example.html#a1">example/fgl/utility/zip.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gadd287096faed2bb17d2e9506c7af45bd" name="gadd287096faed2bb17d2e9506c7af45bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd287096faed2bb17d2e9506c7af45bd">&#9670;&nbsp;</a></span>zip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::forward_range ... T_ranges&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fgl::zip </td>
          <td>(</td>
          <td class="paramtype">T_ranges &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines length from the size of the smallest range. </p>
<dl class="section attention"><dt>Attention</dt><dd>This fascility may be supplanted entirely by C++23's <code>zip_view</code>, depending its performance. If the standard is sufficient or superior, this facility will be removed.</dd></dl>
<p >A zipped range is a <code>std::ranges::subrange</code> composed of an internal zip iterator and a size-based <code>fgl::zip_sentinel_t</code> end sentinel. The length of the zipped range must always be less than or greater to the size of the smallest range, otherwise the behavior is undefined. The zip iterator is internal because it isn't intended to be used directly by the user; usually only by ranged algorithms and range-based <code>for</code> loops.</p>
<p >Dreferencing the zip iterator returns a <code>std::tuple</code> composed of the results from dereferencing the underlying iterators. These may be values or reference-wrappers depending on what the underlying iterators return.</p>
<p ><code>czip</code> ranges use <code>const</code>-qualified underlying iterators from <code>std::cbegin</code> , while <code>zip</code> ranges use iterators from <code>std::begin</code> . </p>
<dl class="section see"><dt>See also</dt><dd>the example program <a class="el" href="example_2fgl_2utility_2zip_8cpp-example.html">example/fgl/utility/zip.cpp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>The ranges to zip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::ranges::subrange</code> which represents the "zipped" ranged. </dd></dl>

</div>
</div>
<a id="ga2782ade415a9fa6ccc855689ad3d91dd" name="ga2782ade415a9fa6ccc855689ad3d91dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2782ade415a9fa6ccc855689ad3d91dd">&#9670;&nbsp;</a></span>czip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::forward_range ... T_ranges&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fgl::czip </td>
          <td>(</td>
          <td class="paramtype">const std::integral auto&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_ranges &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if <code>length</code> is greater than the size of the smallest range. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This fascility may be supplanted entirely by C++23's <code>zip_view</code>, depending its performance. If the standard is sufficient or superior, this facility will be removed.</dd></dl>
<p >A zipped range is a <code>std::ranges::subrange</code> composed of an internal zip iterator and a size-based <code>fgl::zip_sentinel_t</code> end sentinel. The length of the zipped range must always be less than or greater to the size of the smallest range, otherwise the behavior is undefined. The zip iterator is internal because it isn't intended to be used directly by the user; usually only by ranged algorithms and range-based <code>for</code> loops.</p>
<p >Dreferencing the zip iterator returns a <code>std::tuple</code> composed of the results from dereferencing the underlying iterators. These may be values or reference-wrappers depending on what the underlying iterators return.</p>
<p ><code>czip</code> ranges use <code>const</code>-qualified underlying iterators from <code>std::cbegin</code> , while <code>zip</code> ranges use iterators from <code>std::begin</code> . </p>
<dl class="section see"><dt>See also</dt><dd>the example program <a class="el" href="example_2fgl_2utility_2zip_8cpp-example.html">example/fgl/utility/zip.cpp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the shortest range. Must be greater than zero and representible by <code>fgl::zip_sentinel_t</code> </td></tr>
    <tr><td class="paramname">ranges</td><td>The ranges to zip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::ranges::subrange</code> which represents the "zipped" ranged. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="example_2fgl_2utility_2zip_8cpp-example.html#a0">example/fgl/utility/zip.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaff12ff083252eda09571cb8fd8653b7e" name="gaff12ff083252eda09571cb8fd8653b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff12ff083252eda09571cb8fd8653b7e">&#9670;&nbsp;</a></span>czip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::forward_range ... T_ranges&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fgl::czip </td>
          <td>(</td>
          <td class="paramtype">T_ranges &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines length from the size of the smallest range. </p>
<dl class="section attention"><dt>Attention</dt><dd>This fascility may be supplanted entirely by C++23's <code>zip_view</code>, depending its performance. If the standard is sufficient or superior, this facility will be removed.</dd></dl>
<p >A zipped range is a <code>std::ranges::subrange</code> composed of an internal zip iterator and a size-based <code>fgl::zip_sentinel_t</code> end sentinel. The length of the zipped range must always be less than or greater to the size of the smallest range, otherwise the behavior is undefined. The zip iterator is internal because it isn't intended to be used directly by the user; usually only by ranged algorithms and range-based <code>for</code> loops.</p>
<p >Dreferencing the zip iterator returns a <code>std::tuple</code> composed of the results from dereferencing the underlying iterators. These may be values or reference-wrappers depending on what the underlying iterators return.</p>
<p ><code>czip</code> ranges use <code>const</code>-qualified underlying iterators from <code>std::cbegin</code> , while <code>zip</code> ranges use iterators from <code>std::begin</code> . </p>
<dl class="section see"><dt>See also</dt><dd>the example program <a class="el" href="example_2fgl_2utility_2zip_8cpp-example.html">example/fgl/utility/zip.cpp</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>The ranges to zip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::ranges::subrange</code> which represents the "zipped" ranged. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
