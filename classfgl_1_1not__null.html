<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libFGL: fgl::not_null&lt; T, T_use_assertions, T_check_on_access &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="tempus.ico" type="image/x-icon" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<!-- BEGIN CUSTOMIZATIONS -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript"> DoxygenAwesomeFragmentCopyButton.init() </script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript"> DoxygenAwesomeParagraphLink.init() </script>
<!-- END CUSTOMIZATIONS -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="tempus.ico"/></td>
  <td id="projectalign">
   <div id="projectname">libFGL
   </div>
   <div id="projectbrief">Intended for use with Tempus Edax Rerum projects. Replacing spoons with shovels.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classfgl_1_1not__null.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfgl_1_1not__null-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fgl::not_null&lt; T, T_use_assertions, T_check_on_access &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group-types-not__null.html">Not Null Wrapper</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;fgl/types/not_null.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abcac03f7792e9402d26850389f361ad2"><td class="memItemLeft" align="right" valign="top"><a id="abcac03f7792e9402d26850389f361ad2" name="abcac03f7792e9402d26850389f361ad2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>underlying_type</b> = T</td></tr>
<tr class="memdesc:abcac03f7792e9402d26850389f361ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the wrapped <code>T</code> object. <br /></td></tr>
<tr class="separator:abcac03f7792e9402d26850389f361ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a37ffacf749de79d94f1ab10c323a7d30"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#a37ffacf749de79d94f1ab10c323a7d30">copy</a> () const noexcept(std::is_nothrow_copy_constructible_v&lt; T &gt; &amp;&amp;(T_use_assertions||not T_check_on_access))</td></tr>
<tr class="separator:a37ffacf749de79d94f1ab10c323a7d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab336868ad9339304d668c940aaa407d5"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#ab336868ad9339304d668c940aaa407d5">reference</a> () const noexcept(T_use_assertions||not T_check_on_access)</td></tr>
<tr class="separator:ab336868ad9339304d668c940aaa407d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72ad043136d7b837ed731566c180970"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#aa72ad043136d7b837ed731566c180970">unsafe_reference</a> () noexcept</td></tr>
<tr class="separator:aa72ad043136d7b837ed731566c180970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad208f447d59083c2c5ddcd4d24a37a17"><td class="memItemLeft" align="right" valign="top"><a id="ad208f447d59083c2c5ddcd4d24a37a17" name="ad208f447d59083c2c5ddcd4d24a37a17"></a>
constexpr <a class="el" href="classfgl_1_1not__null.html">not_null</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classfgl_1_1not__null.html">not_null</a> &amp;other) noexcept(std::is_nothrow_copy_assignable_v&lt; T &gt;)</td></tr>
<tr class="separator:ad208f447d59083c2c5ddcd4d24a37a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c95546ff29ebb3b8f80873b3d7b9939"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#a0c95546ff29ebb3b8f80873b3d7b9939">operator*</a> () noexcept(noexcept(*m_value) &amp;&amp;(T_use_assertions||not T_check_on_access))</td></tr>
<tr class="separator:a0c95546ff29ebb3b8f80873b3d7b9939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2911d104552715f288b893d527351ad"><td class="memItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#aa2911d104552715f288b893d527351ad">operator*</a> () const noexcept(noexcept(*m_value) &amp;&amp;(T_use_assertions||not T_check_on_access))</td></tr>
<tr class="separator:aa2911d104552715f288b893d527351ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f3a2ea839836474cb6a125a269f25c"><td class="memItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#a55f3a2ea839836474cb6a125a269f25c">operator-&gt;</a> () noexcept(T_use_assertions||not T_check_on_access)</td></tr>
<tr class="separator:a55f3a2ea839836474cb6a125a269f25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8498ea721773aad2c245324eaeaf9df"><td class="memItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#af8498ea721773aad2c245324eaeaf9df">operator-&gt;</a> () const noexcept(T_use_assertions||not T_check_on_access)</td></tr>
<tr class="separator:af8498ea721773aad2c245324eaeaf9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a3318653689caba6bb4501c8f70641468"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#a3318653689caba6bb4501c8f70641468">not_null</a> ()</td></tr>
<tr class="separator:a3318653689caba6bb4501c8f70641468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ebef8e6d70766a79b031a255532759"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#a47ebef8e6d70766a79b031a255532759">not_null</a> (T value) noexcept(T_use_assertions &amp;&amp;std::is_nothrow_move_constructible_v&lt; T &gt;)</td></tr>
<tr class="separator:a47ebef8e6d70766a79b031a255532759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2023407add9b64a958234f491794c003"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfgl_1_1not__null.html#a2023407add9b64a958234f491794c003">not_null</a> (auto &amp;&amp;... args) noexcept(T_use_assertions &amp;&amp;noexcept(T(std::forward&lt; decltype(args)&gt;(args)...)))</td></tr>
<tr class="separator:a2023407add9b64a958234f491794c003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d66cd8d88e9fcf9ae42a8fec8d7b2c"><td class="memItemLeft" align="right" valign="top"><a id="a05d66cd8d88e9fcf9ae42a8fec8d7b2c" name="a05d66cd8d88e9fcf9ae42a8fec8d7b2c"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>not_null</b> (const <a class="el" href="classfgl_1_1not__null.html">not_null</a> &amp;other) noexcept(std::is_nothrow_copy_constructible_v&lt; T &gt;)</td></tr>
<tr class="separator:a05d66cd8d88e9fcf9ae42a8fec8d7b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt;<br />
class fgl::not_null&lt; T, T_use_assertions, T_check_on_access &gt;</div><p >A wrapper which ensures its value never has equality with <code>nullptr</code> .</p>
<p >This wrapper guarentees that its value will never have equality with <code>nullptr</code> by performing comparisons. How and where this not-null 'contract' is enforced depends on the boolean template parameters.</p>
<dl class="section remark"><dt>Remarks</dt><dd><p class="startdd"><code>T&amp;</code> should be preferred over <code>not_null&lt;T*&gt;</code> where possible. However, there are many cases where <code><a class="el" href="classfgl_1_1not__null.html">not_null</a></code> is an optimal solution, such as when interacting with legacy code, or when an interface requires something like <code>fgl::not_null&lt;std::unique_ptr&lt;T&gt;&gt;</code> </p>
<p class="interdd"><code><a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a></code> serves two purposes: both improving code safety and documenting intent within the code itself. This can be compared to the popular <code>gsl::not_null</code> from the Core Guidelines Support Library. <code><a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a></code> is more flexible and configurable than the GSL : It can be made to have zero runtime overhead by using assertions instead of exceptions in cases where that is desirable. It can also be made to eliminate excessive "access" checks when they aren't required (such as with raw pointer types).</p>
<p class="enddd">Enforcement behavior is configured by boolean template parameters. This is a design choice which may be a bit controversial, as most libraries (like the GSL) use macro definitions to configure these behaviors. However, a type-based template approach was chosen to allow greater flexibility along with API / ABI stability. This allows different synthesizations to have different enforcement rules so that each instance can use whichever behavior is most applicable or efficient. </p>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The <code><a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a></code> type to wrap </td></tr>
    <tr><td class="paramname">T_use_assertions</td><td>If true, <a class="el" href="group__group-debug-constexpr__assert.html">Constexpr Assert</a> will be used for enforcement instead of exceptions. This may be used to eliminate overhead when compiling for release with <code>NDEBUG</code> , but of course will also eliminate all <code>nullptr</code> checks. (Default: <code>false</code> , exceptions will be used) </td></tr>
    <tr><td class="paramname">T_check_on_access</td><td>If true, perform <code>nullptr</code> checks upon access such as <code>*</code> , <code>-&gt;</code> , <code><a class="el" href="classfgl_1_1not__null.html#a37ffacf749de79d94f1ab10c323a7d30">copy()</a></code> , and <code><a class="el" href="classfgl_1_1not__null.html#ab336868ad9339304d668c940aaa407d5">reference()</a></code> . This can be used to eliminate redundant checks for types which can't change <code>nullptr</code> equality between accesses (Default: <code>not <a class="el" href="conceptfgl_1_1traits_1_1pointer__type.html">fgl::traits::pointer_type&lt;T&gt;</a></code> as these checks aren't beneficial for raw pointers). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="example_2fgl_2types_2not_null_8cpp-example.html#_a2">example/fgl/types/not_null.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3318653689caba6bb4501c8f70641468" name="a3318653689caba6bb4501c8f70641468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3318653689caba6bb4501c8f70641468">&#9670;&nbsp;</a></span>not_null() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::not_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>only when <ol>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
The default-constructed <code>T</code> has equality with <code>nullptr</code>  </li>
</ol>
Often, the "invalid argument" is in fact a <em>lack</em> of arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47ebef8e6d70766a79b031a255532759" name="a47ebef8e6d70766a79b031a255532759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ebef8e6d70766a79b031a255532759">&#9670;&nbsp;</a></span>not_null() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::not_null </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A non-null value which will be move-constructed as the wrapped object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>only when <ol>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
<code>value</code> has equality with <code>nullptr</code>  </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2023407add9b64a958234f491794c003" name="a2023407add9b64a958234f491794c003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2023407add9b64a958234f491794c003">&#9670;&nbsp;</a></span>not_null() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::not_null </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments to forward to the wrapped object's constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>only when <ol>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
the wrapped object has equality with <code>nullptr</code>  </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a37ffacf749de79d94f1ab10c323a7d30" name="a37ffacf749de79d94f1ab10c323a7d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ffacf749de79d94f1ab10c323a7d30">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a copy of the wrapped object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>only when <ol>
<li>
<code>T_check_on_access</code> is <code>true</code>  </li>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
the wrapped object has equality with <code>nullptr</code>  </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab336868ad9339304d668c940aaa407d5" name="ab336868ad9339304d668c940aaa407d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab336868ad9339304d668c940aaa407d5">&#9670;&nbsp;</a></span>reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T &amp; <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the wrapped object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>only when <ol>
<li>
<code>T_check_on_access</code> is <code>true</code>  </li>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
the wrapped object has equality with <code>nullptr</code>  </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa72ad043136d7b837ed731566c180970" name="aa72ad043136d7b837ed731566c180970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72ad043136d7b837ed731566c180970">&#9670;&nbsp;</a></span>unsafe_reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T &amp; <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::unsafe_reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This method is unsafe for two reasons: it doesn't check for <code>nullptr</code> equality before returning the reference even when <code>T_check_on_access</code> is <code>true</code> , and because it can potentially be used to invalidate the 'not null' guarantee if the wrapped object is modified by reference to have equality with <code>nullptr</code> . The wrapper should be thought of as "dirty" if this method is invoked. This is particularly dangerous if <code>T_check_on_access</code> is <code>false</code> which can lead to invalid assumptions (i.e. when a <code><a class="el" href="classfgl_1_1not__null.html">not_null</a></code> is actually null). However, if <code>T_check_on_access</code> is <code>true</code> then the guarantee can still be enforced by other access methods. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>It's strongly recommended that this method be avoided where possible, especially if <code>T_check_on_access</code> is <code>false</code> . This is provided for completeness and as a way to directly operate on the wrapped instance. For example: swapping or releasing a <code>unique_ptr</code> . </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the wrapped object </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="example_2fgl_2types_2not_null_8cpp-example.html#a3">example/fgl/types/not_null.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0c95546ff29ebb3b8f80873b3d7b9939" name="a0c95546ff29ebb3b8f80873b3d7b9939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c95546ff29ebb3b8f80873b3d7b9939">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The result of dereferencing the wrapped object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>only when <ol>
<li>
<code>T_check_on_access</code> is <code>true</code>  </li>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
the wrapped object has equality with <code>nullptr</code>  </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2911d104552715f288b893d527351ad" name="aa2911d104552715f288b893d527351ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2911d104552715f288b893d527351ad">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto &amp; <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The result of dereferencing the wrapped object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>only when <ol>
<li>
<code>T_check_on_access</code> is <code>true</code>  </li>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
the wrapped object has equality with <code>nullptr</code>  </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55f3a2ea839836474cb6a125a269f25c" name="a55f3a2ea839836474cb6a125a269f25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f3a2ea839836474cb6a125a269f25c">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto &amp; <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>only when <ol>
<li>
<code>T_check_on_access</code> is <code>true</code>  </li>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
the wrapped object has equality with <code>nullptr</code>  </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8498ea721773aad2c245324eaeaf9df" name="af8498ea721773aad2c245324eaeaf9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8498ea721773aad2c245324eaeaf9df">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptfgl_1_1traits_1_1null__comparable.html">fgl::traits::null_comparable</a> T, const bool T_use_assertions = false, const bool T_check_on_access = not fgl::traits::pointer_type&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto &amp; <a class="el" href="classfgl_1_1not__null.html">fgl::not_null</a>&lt; T, T_use_assertions, T_check_on_access &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>only when <ol>
<li>
<code>T_check_on_access</code> is <code>true</code>  </li>
<li>
<code>T_use_assertions</code> is <code>false</code>  </li>
<li>
the wrapped object has equality with <code>nullptr</code>  </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>fgl</b></li><li class="navelem"><a class="el" href="classfgl_1_1not__null.html">not_null</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
